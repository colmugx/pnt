# Internationalization (i18n) Guide

Mug provides built-in internationalization support with English and Chinese translations. This guide shows how to use and extend i18n in your CLI applications.

## Overview

Mug's i18n system:
- Auto-detects system locale from environment variables
- Includes built-in English and Chinese translations
- Allows custom translations for your application
- Can be enabled/disabled as needed

## Basic Usage

### Automatic Locale Detection

By default, Mug detects the system locale:

```mbt
let app = @app.App::new("mycli", "My CLI tool")

// i18n is automatically initialized with detected locale
// If LC_ALL, LANG, or LC_MESSAGES is set to "zh_CN.UTF-8",
// it will use "zh-CN" translations
```

### Setting a Specific Locale

Override the auto-detected locale:

```mbt
let app = @app.App::new("mycli", "My CLI tool")
let app_zh = app.with_locale("zh-CN")
```

Supported locales:
- `en-US` - English (United States)
- `zh-CN` - Chinese (Simplified)

## Using i18n in Commands

Access translations through the app's i18n instance:

```mbt
pub struct MyCommand {
  app: @app.App
}

impl TCommand for MyCommand with description(self) {
  self.app.i18n.t("my.command.description")
}

impl TCommand for MyCommand with execute(self, args) {
  let msg = self.app.i18n.t("messages.welcome")
  println(msg)
}
```

## Adding Custom Translations

Define your own translation keys:

```mbt
let app = @app.App::new("mycli", "My CLI tool")

let custom_translations : Map[String, String] = {
  "greeting": "Welcome to MyCLI",
  "farewell": "Goodbye!",
  "commands.list.description": "List all items",
  "errors.file_not_found": "File not found: \{path}"
}

let app_with_translations = app.with_translations("en-US", custom_translations)

// Now use your custom keys
let msg = app_with_translations.i18n.t("greeting")
// Output: "Welcome to MyCLI"
```

## Built-in Translation Keys

Mug includes these built-in translation keys:

| Key | English | Chinese (Simplified) |
|-----|---------|---------------------|
| `help` | "Show help information" | "显示帮助信息" |
| `version` | "Show version" | "显示版本信息" |
| `command.not_found` | "Command not found" | "未找到命令" |
| `error.unknown_flag` | "Unknown flag" | "未知标志" |
| `error.missing_value` | "Missing value for flag" | "标志缺少值" |
| `app.usage` | "Usage" | "用法" |
| `app.available_commands` | "Available commands" | "可用命令" |
| `app.options` | "Options" | "选项" |

## Disabling i18n

Disable translations to always use English (or return the key itself if not found):

```mbt
let app = @app.App::new("mycli", "My CLI tool")
let app_disabled = app.disable_i18n()

// All calls to t() will return English fallback or the key itself
let text = app_disabled.i18n.t("some.key")
// Returns: "some.key" (if no English translation exists)
```

### Re-enabling i18n

```mbt
let app_enabled = app_disabled.enable_i18n()
```

## Translation File Format

If you want to organize translations in files, use JSON format:

```json
// lang/en.json
{
  "greeting": "Welcome",
  "commands": {
    "download": {
      "description": "Download files",
      "success": "Downloaded successfully",
      "error": "Download failed"
    }
  }
}

// lang/zh-cn.json
{
  "greeting": "欢迎",
  "commands": {
    "download": {
      "description": "下载文件",
      "success": "下载成功",
      "error": "下载失败"
    }
  }
}
```

Load and use these translations:

```mbt
// Assuming you've loaded the JSON into a Map
let translations = load_json("lang/en.json")
let app = @app.App::new("mycli", "My CLI tool")
  .with_translations("en-US", translations)
```

## Best Practices

### 1. Use Namespaced Keys

```mbt
// Good - clear hierarchy
"commands.download.description"
"errors.file.not_found"

// Bad - flat structure
"download_desc"
"file_error"
```

### 2. Provide English Fallbacks

```mbt
// Always include English translations as fallback
let app = @app.App::new("mycli", "My CLI tool")
  .with_translations("en-US", english_translations)
```

### 3. Handle Missing Keys

```mbt
// When a key is missing, t() returns the key itself
let text = app.i18n.t("nonexistent.key")
// Returns: "nonexistent.key"
```

### 4. Use Descriptive Key Names

```mbt
// Good
"commands.deploy.description"

// Bad
"desc1"
```

## Complete Example

```mbt
fn main {
  // Create app with i18n
  let app = @app.App::new("deployer", "Deployment tool")

  // Add custom translations
  let translations : Map[String, String] = {
    "commands.deploy.description": "Deploy to server",
    "commands.deploy.success": "Deployment successful",
    "commands.deploy.error": "Deployment failed",
    "messages.connecting": "Connecting to server...",
    "messages.building": "Building project..."
  }

  let app_i18n = app.with_translations("en-US", translations)

  // Add command that uses i18n
  let deploy = DeployCommand::{ app: app_i18n }
  app_i18n.add_command(deploy)

  // Execute
  app_i18n.execute(@sys.argv.get_view())
}

pub struct DeployCommand {
  app: @app.App
}

impl TCommand for DeployCommand with description(self) {
  self.app.i18n.t("commands.deploy.description")
}

impl TCommand for DeployCommand with execute(self, args) {
  println(self.app.i18n.t("messages.connecting"))

  // Deployment logic here

  if success {
    println(self.app.i18n.t("commands.deploy.success"))
  } else {
    println(self.app.i18n.t("commands.deploy.error"))
  }
}
```

## Advanced: Locale Detection

Mug detects locale from environment variables in this priority order:

1. `LC_ALL` - Highest priority
2. `LANG` - Medium priority
3. `LC_MESSAGES` - Lowest priority
4. Defaults to `en-US` if none set

Example locale formats:
- `zh_CN.UTF-8` → `zh-CN`
- `en_US.UTF-8` → `en-US`
- `ja` → `ja-JP`

For more details, see the [locale detection implementation](../src/i18n/locale.mbt).
